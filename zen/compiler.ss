(define (op->inst op)
  (cdr (assq op `((+ . ,(tuple IPlus))
                  (- . ,(tuple ISub))
                  (* . ,(tuple IMul))
                  (/ . ,(tuple IDiv))
                  (= . ,(tuple IEqual))))))

(define (compile exp code)
  (match-tuple exp
               ((Int v) (cons (tuple IConst v) code))
               ((Bool v) (cons (tuple IBool v) code))
               ((String s) (cons (tuple IString s) code))
               ((Load s) (compile s (cons (tuple ILoad) code)))
               ((Var n) (cons (tuple IAccess n) code))
               ((Fun n ts)
                (cons (tuple IClosure (compile-tail exp )) code))
               ;; ((Fun1 n ts)
               ;;  (cons (tuple IClosure (compile-tail exp n)) code))
               ;; ((Let n ts)
               ;;  (cons (tuple ILet n)
               ;;        (fold-left
               ;;         (lambda (o x)
               ;;           (compile x o (+ threshold n)))
               ;;         (cons (tuple IEndLet n) code)
               ;;         (reverse ts))))
               ((Set n v)
                (compile v (cons (tuple ISet n) code)))
               ((CCall fn ts)
                (let ((init (cons (tuple IString fn)
                                  (cons (tuple ICCall (length ts))
                                        code)))
                      (f (lambda (a b)
                           (compile b (cons (tpule IPush) a)))))
                  (fold-left f init ts)))
               ((App)
                (cons (tuple IPushMark)
                      (append (compile-tail exp ) code)))
               ((Prim op a b)
                (compile a
                         (cons (tuple IPush)
                               (compile b
                                        (cons (op->inst op) code)
                                        ))
                         ))
               ((If a b c)
                (compile a
                         (cons (tuple IBranch (compile b code )
                                      (compile c code )) '())
                         ))
               ))

(define (compile-tail exp )
  (case exp
    (Int (compile exp (cons (tuple IReturn) '()) ))
    (Bool (compile exp (cons (tuple IReturn) '()) ))
    (String (compile exp (cons (tuple IReturn) '()) ))
    (CCall (compile exp (cons (tuple IReturn) '()) ))
    (Load (compile exp (cons (tuple IReturn) '()) ))
    (Var (compile exp (cons (tuple IReturn) '()) ))
    (Prim (compile exp (cons (tuple IReturn) '()) ))
    ;; (Let (compile exp (cons (tuple IReturn) '()) ))
    (Set (compile exp (cons (tuple IReturn) '()) ))
    (Fun (let ((n (field 0 exp))
               (ts (field 1 exp)))
           (cons (tuple IGrab n) (compile-body ts))))
    ;; (Fun1 (let ((n (field 0 exp))
    ;;             (ts (field 1 exp)))
    ;;         (append
    ;;          (cons (tuple IGrab (- n 1))
    ;;                (cons (tuple IPush) (compile-body ts n)))
    ;;          (cons (tuple IReturn) '()))))
    (App (let ((t (field 0 exp))
               (ts (field 1 exp)))
           (let ((init (compile t (cons (tuple IApply) '()) ))
                 (f (lambda (a b)
                      (compile b a ))))
             (fold-left f init ts))))
    ))

(define (compile-body ts )
  (if (null? ts) '()
      (if (null? (cdr ts))
          (compile (car ts) (cons (tuple IReturn) '()) )
          (compile (car ts)
                   (compile-body (cdr ts) ) ))))
