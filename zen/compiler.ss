(define (op->inst op)
  (cdr (assq op `((+ . ,(tuple IPlus))
                  (- . ,(tuple ISub))
                  (* . ,(tuple IMul))
                  (/ . ,(tuple IDiv))
                  (= . ,(tuple IEqual))))))

(define (compile exp code threshold)
  (match-tuple exp
               ((Int v) (cons (tuple IConst v) code))
               ((Bool v) (cons (tuple IBool v) code))
               ((String s) (cons (tuple IString s) code))
               ((Load s) (compile s (cons (tuple ILoad) code) threshold))
               ((Var n)
                (if (< n threshold)
                    (cons (tuple IStackAccess n) code)
                    (cons (tuple IEnvAccess (- n threshold)) code)))
               ((Fun n ts)
                (cons (tuple IClosure (compile-tail exp n)) code))
               ((Fun1 n ts)
                (cons (tuple IClosure (compile-tail exp n)) code))
               ((Let n ts)
                (cons (tuple ILet n)
                      (fold-left
                       (lambda (o x)
                         (compile x o (+ threshold n)))
                       (cons (tuple IEndLet n) code)
                       (reverse ts))))
               ((Set n v)
                (compile v (cons (tuple ISet n) code) threshold))
               ((CCall fn ts)
                (let ((init (cons (tuple IString fn)
                                  (cons (tuple ICCall (length ts))
                                        code)))
                      (f (lambda (a b)
                           (compile b (cons (tpule IPush) a) threshold))))
                  (fold-left f init ts)))
               ((App)
                (cons (tuple IPushRetAddr code) (compile-tail exp threshold)))
               ((Prim op a b)
                (compile a
                         (cons (tuple IPush)
                               (compile b
                                        (cons (op->inst op) code)
                                        threshold))
                         threshold))
               ((If a b c)
                (compile a
                         (cons (tuple IBranch (compile b code threshold)
                                      (compile c code threshold)) '())
                         threshold))
               ))

(define (compile-tail exp threshold)
  (case exp
    (Int (compile exp (cons (tuple IReturn) '()) threshold))
    (Bool (compile exp (cons (tuple IReturn) '()) threshold))
    (String (compile exp (cons (tuple IReturn) '()) threshold))
    (CCall (compile exp (cons (tuple IReturn) '()) threshold))
    (Load (compile exp (cons (tuple IReturn) '()) threshold))
    (Var (compile exp (cons (tuple IReturn) '()) threshold))
    (Prim (compile exp (cons (tuple IReturn) '()) threshold))
    (Let (compile exp (cons (tuple IReturn) '()) threshold))
    (Set (compile exp (cons (tuple IReturn) '()) threshold))
    (Fun (let ((n (field 0 exp))
               (ts (field 1 exp)))
           (cons (tuple IGrab n) (compile-body ts n))))
    (Fun1 (let ((n (field 0 exp))
                (ts (field 1 exp)))
            (append
             (cons (tuple IGrab (- n 1))
                   (cons (tuple IPush) (compile-body ts n)))
             (cons (tuple IReturn) '()))))
    (App (let ((t (field 0 exp))
               (ts (field 1 exp)))
           (let ((init (compile t (cons (tuple IApply) '()) threshold))
                 (f (lambda (a b)
                      (compile b (cons (tuple IPush) a) threshold))))
             (fold-left f init ts))))
    ))

(define (compile-body ts threshold)
  (if (null? ts) '()
      (if (null? (cdr ts))
          (compile (car ts) (cons (tuple IReturn) '()) threshold)
          (compile (car ts)
                   (compile-body (cdr ts) threshold) threshold))))
