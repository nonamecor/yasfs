变量  只不过是给事物命一个名字   环境中第1个 环境中第2个 环境中第47个...
alpha变换，把名字变成在环境中的位置

值 不用管它存在哪里

f(x) = x + 1
(lambda (x) (+ x 1))
fn x => x + 1
fn x -> x + 1
\x -> x + 1
x => x + 1
function (x) { return x + 1; }
lambda x: x + 1
[:x | x + 1]
Function(x) x + 1

M1 M2 M3 ... Mn   ((((M1 M2) M3) ... ) Mn)
必须用括号来表示结合的顺序

匿名函数的写法
fn x -> x + 1

变量绑定的写法，含义是在当前环境里面绑定变量，这不是赋值！
a := 3
a, b, c := 1, 2, 3
计算右值时，左边变量在环境中不可见

函数的写法，其实是语法糖
fn f x => x + x
等价于在全局环境中 匿名函数 + 变量绑定
f := fn x -> x + 1

以下代码
fn f x =>
   a := 3
   b := 5
   a+b+x
跟ML代码等的
let f x =
    let a = 3 in
    let b = 5 in
        a + b + x

f := fn x -> x + 1
let f g h =
  g := 3
  h := f g

柯里化
fn x y z -> M
等价于
fn x ->
   fn y ->
      fn z ->
         M

第一期做基本的语法解析、zinc的虚拟机模型、无类型lambda演算
之后加条件 循环 分支
然后是简单类型推导
patten match是需要的，但是第一期暂时不做，至少要做完type infer
