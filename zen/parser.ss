(define (Int v) (tuple Int v))
(define (Bool v) (tuple Bool v))
(define (String v) (tuple String v))
(define (Var s) (tuple Var s))
(define (Var&s v) (case v (Var (field 0 v))))
(define (App t ts) (tuple App t ts))
(define (App&t v) (case v (App (field 0 v))))
(define (App&ts v) (case v (App (field 1 v))))
(define (Fun args ts) (tuple Fun args ts))
(define (Fun1 args ts) (tuple Fun1 args ts))
(define (If t1 t2 t3) (tuple If t1 t2 t3))
(define (Plus t1 t2) (tuple Plus t1 t2))
(define (Sub t1 t2) (tuple Sub t1 t2))
(define (Mul t1 t2) (tuple Mul t1 t2))
(define (Div t1 t2) (tuple Div t1 t2))
(define (Equal t1 t2) (tuple Equal t1 t2))
(define (Tuple tag ls) (tuple Tuple tag ls))
(define (Tuple&tag t) (case t (Tuple (field 0 t))))
(define (Tuple&ls t) (case t (Tuple (field 1 t))))
(define (Field n t) (tuple Field n t))
(define (Switch t ls) (tuple Switch t ls))
(define (Set v t) (tuple Set v t))
(define (Let ls ts) (tuple Let ls ts))
(define (Load t) (tuple Load t))

;; macro0把(define (f x) ...)变成(define f (lambda (x) ...))
(define (macro0 exp)
  (if (not (pair? exp)) exp
      (let ((hd (car exp))
            (tl (cdr exp)))
        (cond
         ((eq? hd 'define)
          (if (pair? (car tl))
              (let ((body `(lambda ,(cdar tl) ,@(cdr tl))))
                `(define ,(caar tl) ,(macro0 body)))
              `(define ,(car tl) ,@(map macro0 (cdr tl)))))
         ((eq? hd 'if)
          `(if ,(macro0 (car tl)) ,(macro0 (cadr tl)) ,(macro0 (caddr tl))))
         ((eq? hd 'field)
          `(field ,(car tl) ,(macro0 (cadr tl))))
         ((eq? hd 'tuple)
          `(tuple ,(car tl) ,@(map macro0 (cdr tl))))
         ((eq? hd 'lambda)
          `(lambda ,(car tl) ,@(map macro0 (cdr tl))))
         ((eq? hd 'case)
          `(case ,(macro0 (car tl))
             ,@(map (lambda (x)
                     (cons (car x) (macro0 (cdr x))))
                   (cdr tl))))
         ((eq? hd 'let)
          `(let ,(car tl) ,@(map macro0 (cdr tl))))
         ((or (eq? hd '+) (eq? hd '-) (eq? hd '*) (eq? hd '/) (eq? hd '=))
          `(,hd ,(macro0 (car tl)) ,(macro0 (cadr tl))))
         (#t `(,(macro0 hd) ,@(map macro0 tl)))))))


(define remove
  (lambda (x ls)
    (cond
     ((null? ls) '())
     ((eq? x (car ls))
      (remove x (cdr ls)))
     (else
      (cons (car ls) (remove x (cdr ls)))))))

(define difference
  (lambda (lst1 lst2)
    (if (not (pair? lst2))
        lst1
        (difference (remove (car lst2) lst1) (cdr lst2)))))

(define insert
  (lambda (x ls)
    (cond
     ((null? ls) (cons x '()))
     ((eq? (car ls) x) ls)
     (else (cons (car ls)
                 (insert x (cdr ls)))))))

(define union
  (lambda (lst1 lst2)
    (if (null? lst1)
        lst2
        (insert (car lst1)
                (union (cdr lst1) lst2)))))

(define reduce
  (lambda (f ls rv)
    (if (null? ls)
        rv
        (reduce f (cdr ls) (f (car ls) rv)))))

(define free-vars
  (lambda (exp)
    (cond
     ((or (integer? exp) (string? exp)) '())
     ((symbol? exp)
      (if (member exp '(tuple switch case = + - * /))
          '()
          (list exp)))
     ((eq? 'if (car exp))
      (union (free-vars (cadr exp))
             (union (free-vars (caddr exp))
                    (free-vars (cadddr exp)))))
     ((eq? 'lambda (car exp))
      (difference (free-vars (cddr exp))
                  (cadr exp)))
     ((eq? 'define (car exp))
      (difference  (free-vars (caddr exp))
                   (list (cadr exp))))
     (else (reduce union (map free-vars exp) '())))))

;; 把(define f (lambda (x) ...))变成(define f (lambda1 (this x) ...))
(define (macro1 exp)
  (if (not (pair? exp)) exp
      (let ((hd (car exp))
            (tl (cdr exp)))
        (cond
         ((eq? hd 'define)
          (let ((body (macro1 (cadr tl)))
                (fv (free-vars (cadr tl))))
            (if (member (car tl) fv)
                `(define ,(car tl)
                   (lambda1 ,(cons (car tl) (cadr body))
                            ,@(cddr body)))
                `(define ,(car tl) ,body))))
         ((eq? hd 'if)
          `(if ,(macro1 (car tl)) ,(macro1 (cadr tl)) ,(macro1 (caddr tl))))
         ((eq? hd 'field)
          `(field ,(car tl) ,(macro1 (cadr tl))))
         ((eq? hd 'tuple)
          `(tuple ,(car tl) ,@(map macro1 (cdr tl))))
         ((eq? hd 'lambda)
          `(lambda ,(car tl) ,@(map macro1 (cdr tl))))
         ((eq? hd 'case)
          `(case ,(macro1 (car tl))
             ,@(map (lambda (x)
                     (cons (car x) (macro1 (cdr x))))
                   (cdr tl))))
         ((eq? hd 'let)
          `(let ,(car tl) ,@(map macro0 (cdr tl))))
         ((or (eq? hd '+) (eq? hd '-) (eq? hd '*) (eq? hd '/) (eq? hd '=))
          `(,hd ,(macro1 (car tl)) ,(macro1 (cadr tl))))
         (#t `(,(macro1 hd) ,@(map macro1 tl)))))))

;; 把(lambda () (define f ...) (define g ...) (define h ...) ...)变成
;; (let ((f ...) (g ...) (h ...)) ...)
(define (macro2 exp)
  (if (not (pair? exp)) exp
      (let ((hd (car exp))
            (tl (cdr exp)))
        (cond
         ((eq? hd 'define)
          `(define ,(car tl) ,@(map macro2 (cdr tl))))
         ((eq? hd 'if)
          `(if ,(macro2 (car tl)) ,(macro2 (cadr tl)) ,(macro2 (caddr tl))))
         ((eq? hd 'field)
          `(field ,(car tl) ,(macro2 (cadr tl))))
         ((eq? hd 'tuple)
          `(tuple ,(car tl) ,@(map macro2 (cdr tl))))
         ((eq? hd 'lambda)
          (let ((fn (lambda (x)
                      (and (pair? x) (eq? (car x) 'define))))
                (body (map macro2 (cdr tl))))
            (let ((defs (filter fn body))
                  (rem (filter (lambda (x) (not (fn x))) body)))
              (if (null? defs)
                  `(lambda ,(car tl) ,@body)
                  `(lambda ,(car tl)
                     (let ,(map cdr defs)
                       ,@rem))))))
         ((eq? hd 'case)
          `(case ,(macro2 (car tl))
             ,@(map (lambda (x)
                     (cons (car x) (macro2 (cdr x))))
                   (cdr tl))))
         ((eq? hd 'let)
          `(let ,(car tl) ,@(map macro0 (cdr tl))))
         ((or (eq? hd '+) (eq? hd '-) (eq? hd '*) (eq? hd '/) (eq? hd '=))
          `(,hd ,(macro2 (car tl)) ,(macro2 (cadr tl))))
         (else `(,(macro2 hd) ,@(map macro2 tl)))))))

(define (parse exp)
  (if (pair? exp)
      (parse-sexp exp)
      (parse-atom exp)))

(define (parse-atom v)
  (cond
   ((boolean? v) (Bool v))
   ((integer? v) (Int v))
   ((string? v) (String v))
   ((symbol? v) (Var v))))

(define (parse-sexp exp)
  (let ((hd (car exp))
        (tl (cdr exp)))
    (cond
     ((eq? hd 'if)
      (If (parse (car tl)) (parse (cadr tl)) (parse (caddr tl))))
     ((eq? hd '+)
      (Plus (parse (car tl)) (parse (cadr tl))))
     ((eq? hd '-)
      (Sub (parse (car tl)) (parse (cadr tl))))
     ((eq? hd '*)
      (Mul (parse (car tl)) (parse (cadr tl))))
     ((eq? hd '/)
      (Div (parse (car tl)) (parse (cadr tl))))
     ((eq? hd 'load)
      (Load (parse (car tl))))
     ((eq? hd 'field)
      (Field (car tl) (parse (cadr tl))))
     ((eq? hd 'lambda)
      (Fun (car tl) (map parse (cdr tl))))
     ((eq? hd 'lambda1)
      (Fun1 (car tl) (map parse (cdr tl))))
     ((eq? hd 'tuple)
      (Tuple (car tl) (map parse (cdr tl))))
     ((eq? hd '=)
      (Equal (parse (car tl)) (parse (cadr tl))))
     ((eq? hd 'case)
      (Switch (parse (car tl))
              (map (lambda (x)
                     (cons (car x) (parse (cadr x))))
                   (cdr tl))))
     ((eq? hd 'let)
      (let ((arg-list (map car (car tl)))
            (header (map
                     (lambda (x)
                       (Set (car x)
                            (parse (cadr x))))
                     (car tl)))
            (body (map parse (cdr tl))))
        (Let arg-list (append header body))))
     (#t (App (parse hd) (map parse tl))))))
