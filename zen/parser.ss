(define (find-env env v)
  (define (find e v i)
    (if (null? e) (+ 3 "find-env fail and panic")
        (if (eq? (car e) v)
            i
            (find (cdr e) v (+ i 1)))))
  (find env v 0))

(define (extend-env env v)
  (if (null? v)
      env
      (extend-env (cons (car v) env) (cdr v))))

(define (parse exp env)
  (if (pair? exp)
      (parse-sexp exp env)
      (parse-atom exp env)))

(define (parse-atom v env)
  (cond
   ((boolean? v) (tuple Bool v))
   ((integer? v) (tuple Int v))
   ((string? v) (tuple String v))
   ((symbol? v)
    (let ((find (find-env env v)))
      (if find (tuple Var find) (+ 3 "find env fail"))))))

(define (parse-sexp exp env)
  (let ((hd (car exp))
        (tl (cdr exp)))
    (cond
     ((eq? hd 'if)
      (tuple If (parse (car tl) env)
          (parse (cadr tl) env)
          (parse (caddr tl) env)))
     ((memq hd '(+ - * / =))
      (tuple Prim hd (parse (car tl) env) (parse (cadr tl) env)))
     ((eq? hd 'load)
      (tuple Load (parse (car tl) env)))
     ((eq? hd 'lambda)
      (tuple Fun (length (car tl))
           (let ((nenv (extend-env env (cadr exp))))
             (map
              (lambda (x) (parse x nenv))
              (cdr tl)))))
     ((eq? hd 'lambda1)
      (tuple Fun1 (length (car tl))
            (let ((nenv (extend-env env (cadr exp))))
              (map
               (lambda (x) (parse x nenv))
               (cdr tl)))))
     ;; ((eq? hd 'let)
     ;;  (let ((arg-list (map car (car tl)))
     ;;        (header (map
     ;;                 (lambda (x)
     ;;                   (Set (find-env env (car x))
     ;;                        (parse (cadr x) env)))
     ;;                 (car tl)))
     ;;        (body (map (lambda (x) (parse x env)) (cdr tl))))
     ;;    (parse-let (Let arg-list (append header body)) env)))
     ((eq? hd 'ccall)
      (tuple CCall (car tl) (map
                       (lambda (x) (parse x env))
                       (cdr tl))))
     (#t (tuple App (parse hd env) (map (lambda (x) (parse x env)) tl))))))
