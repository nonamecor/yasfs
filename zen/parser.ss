(define (Int v) (tuple Int v))
(define (Bool v) (tuple Bool v))
(define (String v) (tuple String v))
(define (Var s) (tuple Var s))
(define (Var&s v) (case v (Var (field 0 v))))
(define (App t ts) (tuple App t ts))
(define (App&t v) (case v (App (field 0 v))))
(define (App&ts v) (case v (App (field 1 v))))
(define (Fun args ts) (tuple Fun args ts))
(define (Fun1 args ts) (tuple Fun1 args ts))
(define (If t1 t2 t3) (tuple If t1 t2 t3))
(define (Plus t1 t2) (tuple Plus t1 t2))
(define (Sub t1 t2) (tuple Sub t1 t2))
(define (Mul t1 t2) (tuple Mul t1 t2))
(define (Div t1 t2) (tuple Div t1 t2))
(define (Equal t1 t2) (tuple Equal t1 t2))
(define (Tuple tag ls) (tuple Tuple tag ls))
(define (Tuple&tag t) (case t (Tuple (field 0 t))))
(define (Tuple&ls t) (case t (Tuple (field 1 t))))
(define (Switch t ls) (tuple Switch t ls))
(define (Set v t) (tuple Set v t))
(define (Let ls ts) (tuple Let ls ts))
(define (Load t) (tuple Load t))
(define (CCall s ts) (tuple CCall s ts))

(define (find-env env v)
  (define (find e v i)
    (if (null? e) (+ 3 "find-env fail and panic")
        (if (eq? (car e) v)
            i
            (find (cdr e) v (+ i 1)))))
  (find env v 0))

(define (extend-env env v)
  (if (null? v)
      env
      (extend-env (cons (car v) env) (cdr v))))

(define empty-env (lambda () '()))

(define (ast2lambda env ast)
  (case ast
    (Bool ast)
    (Int ast)
    (String ast)
    (Load ast)
    (Fun
     (let ((args (field 0 ast))
           (ts (field 1 ast)))
       (let ((len (length args))
             (new-env (extend-env env args))
             (fn (lambda (e)
                   (lambda (v)
                     (ast2lambda e v)))))
         (Fun len (map (fn new-env) ts)))))
    (Fun1
     (let ((args (field 0 ast))
           (ts (field 1 ast)))
       (let ((len (length args))
             (new-env (extend-env env args))
             (fn (lambda (e)
                   (lambda (v)
                     (ast2lambda e v)))))
         (Fun1 len (map (fn new-env) ts)))))
    (Var (Var (find-env env (Var&s ast))))
    (Set (Set (find-env env (field 0 ast))
              (ast2lambda env (field 1 ast))))
    (Let
     (let ((arg-list (field 0 ast))
           (body (field 1 ast)))
       (Let (length arg-list)
            (map
             (lambda (x)
               (ast2lambda (extend-env env arg-list) x))
             body))))
    (App (App
          (ast2lambda env (App&t ast))
          (let ((fn (lambda (env)
                      (lambda (x)
                        (ast2lambda env x)))))
            (map (fn env) (App&ts ast)))))
    (CCall (CCall (field 0 ast)
                  (map (lambda (v)
                         (ast2lambda env v))
                       (field 1 ast))))
    (Plus
     (Plus (ast2lambda env (field 0 ast))
           (ast2lambda env (field 1 ast))))
    (Sub
     (Sub (ast2lambda env (field 0 ast))
          (ast2lambda env (field 1 ast))))
    (Mul
     (Mul (ast2lambda env (field 0 ast))
          (ast2lambda env (field 1 ast))))
    (Div
     (Div (ast2lambda env (field 0 ast))
          (ast2lambda env (field 1 ast))))
    (If (If (ast2lambda env (field 0 ast))
            (ast2lambda env (field 1 ast))
            (ast2lambda env (field 2 ast))))
    (Equal
     (Equal (ast2lambda env (field 0 ast))
            (ast2lambda env (field 1 ast))))
    ))

(define (parse exp)
  (if (pair? exp)
      (parse-sexp exp)
      (parse-atom exp)))

(define (parse-atom v)
  (cond
   ((boolean? v) (Bool v))
   ((integer? v) (Int v))
   ((string? v) (String v))
   ((symbol? v) (Var v))))

(define (parse-sexp exp)
  (let ((hd (car exp))
        (tl (cdr exp)))
    (cond
     ((eq? hd 'if)
      (If (parse (car tl)) (parse (cadr tl)) (parse (caddr tl))))
     ((eq? hd '+)
      (Plus (parse (car tl)) (parse (cadr tl))))
     ((eq? hd '-)
      (Sub (parse (car tl)) (parse (cadr tl))))
     ((eq? hd '*)
      (Mul (parse (car tl)) (parse (cadr tl))))
     ((eq? hd '/)
      (Div (parse (car tl)) (parse (cadr tl))))
     ((eq? hd 'load)
      (Load (parse (car tl))))
     ((eq? hd 'lambda)
      (Fun (car tl) (map parse (cdr tl))))
     ((eq? hd 'lambda1)
      (Fun1 (car tl) (map parse (cdr tl))))
     ((eq? hd '=)
      (Equal (parse (car tl)) (parse (cadr tl))))
     ((eq? hd 'let)
      (let ((arg-list (map car (car tl)))
            (header (map
                     (lambda (x)
                       (Set (car x)
                            (parse (cadr x))))
                     (car tl)))
            (body (map parse (cdr tl))))
        (Let arg-list (append header body))))
     ((eq? hd 'ccall)
      (CCall (car tl) (map parse (cdr tl))))
     (#t (App (parse hd) (map parse tl))))))
