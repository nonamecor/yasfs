(define idSTOP     1)
(define idPUSHADDR  2)
(define idCONST    3)
(define idPUSH     4)
(define idCLOSURE  5)
(define idAPPLY    6)
(define idGRAB     7)
(define idRESTART   8)
(define idSTACKACC  9)
(define idENVACC   10)
(define idADDINT   11)
(define idRETURN   12)
(define idBRANCH   13)
(define idBRANCHIF  14)
(define idEQ       15)
(define idSUBINT   16)
(define idMULINT   17)
(define idDIVINT   18)
(define idMAKEBLOCK  19)
(define idGETFIELD  20)
(define idSWITCH   21)
(define idCCALL    22)
(define idSTRING    23)

(define (put-u32 p u)
  (let ((v0 (bitwise-and u 255))
        (v1 (bitwise-and (bitwise-arithmetic-shift-right u 8) 255))
        (v2 (bitwise-and (bitwise-arithmetic-shift-right u 16) 255))
        (v3 (bitwise-and (bitwise-arithmetic-shift-right u 24) 255)))
    (put-u8 p v0)
    (put-u8 p v1)
    (put-u8 p v2)
    (put-u8 p v3)))

(define (put-u64 p u)
  (let ((v0 (bitwise-and u 4294967295))
        (v1 (bitwise-and (bitwise-arithmetic-shift-right u 32) 4294967295)))
    (put-u32 p v0)
    (put-u32 p v1)))

(define (emit-inst p x)
  (case x
    (IConst
     (begin (put-u8 p idCONST)
            (put-u64 p (+ 1 (* 2 (field 0 x))))))
    (IBool
     (begin (put-u8 p idCONST)
            (put-u64 p (if (field 0 x) 18 34))))
    (IStop (put-u8 p idSTOP))
    (IApply (put-u8 p idAPPLY))
    (IPlus (put-u8 p idADDINT))
    (ISub (put-u8 p idSUBINT))
    (IMul (put-u8 p idMULINT))
    (IDiv (put-u8 p idDIVINT))
    (IReturn (put-u8 p idRETURN))
    (IClosure
     (let-values (((op g) (open-bytevector-output-port)))
       (for-each (lambda (x) (emit-inst op x)) (field 0 x))
       (put-u8 p idCLOSURE)
       (let ((bv (g)))
         (put-u32 p (bytevector-length bv))
         (put-bytevector p bv))))
    (IGrab
     (begin
       (put-u8 p idRESTART)
       (put-u8 p idGRAB)
       (put-u8 p (field 0 x))))
    (IPushRetAddr
     (let-values (((op g) (open-bytevector-output-port)))
       (for-each (lambda (x) (emit-inst op x)) (field 0 x))
       (let ((bv (g)))
         (put-u8 p idPUSHADDR)
         (put-u32 p (bytevector-length bv))
         (put-bytevector p bv))))
    (IPush (put-u8 p idPUSH))
    (IStackAccess
     (begin (put-u8 p idSTACKACC)
            (put-u8 p (field 0 x))))
    (IEnvAccess
     (begin (put-u8 p idENVACC)
            (put-u8 p (field 0 x))))
    (IBranch
     (let-values (((op1 g1) (open-bytevector-output-port))
                  ((op2 g2) (open-bytevector-output-port)))
       (for-each (lambda (x) (emit-inst op1 x)) (field 0 x))
       (for-each (lambda (x) (emit-inst op2 x)) (field 1 x))
       (let ((bv1 (g1))
             (bv2 (g2)))
         (put-u8 p idBRANCHIF)
         (put-u32 p (+ 5 (bytevector-length bv2)))
         (put-bytevector p bv2)
         (put-u8 p idBRANCH)
         (put-u32 p (bytevector-length bv1))
         (put-bytevector p bv1))))
    (IEqual (put-u8 p idEQ))
    ))
