(define idSTOP     1)
(define idPUSHMARK 2)
(define idCONST    3)
(define idPUSH     4)
(define idCLOSURE  5)
(define idAPPLY    6)
(define idGRAB     7)
(define idRESTART  8)
(define idACCESS   9)
(define idADDINT   11)
(define idRETURN   12)
(define idBRANCH   13)
(define idBRANCHIF  14)
(define idEQ       15)
(define idSUBINT   16)
(define idMULINT   17)
(define idDIVINT   18)
(define idMAKEBLOCK  19)
(define idGETFIELD  20)
(define idSWITCH   21)
(define idCCALL    22)
(define idSTRING   23)
(define idASSIGN   24)
(define idLET      25)
(define idENDLET   26)
(define idLOAD     27)

(define (put-u32 p u)
  (let ((v0 (bitwise-and u 255))
        (v1 (bitwise-and (bitwise-arithmetic-shift-right u 8) 255))
        (v2 (bitwise-and (bitwise-arithmetic-shift-right u 16) 255))
        (v3 (bitwise-and (bitwise-arithmetic-shift-right u 24) 255)))
    (put-u8 p v0)
    (put-u8 p v1)
    (put-u8 p v2)
    (put-u8 p v3)))

(define (put-u64 p u)
  (let ((v0 (bitwise-and u 4294967295))
        (v1 (bitwise-and (bitwise-arithmetic-shift-right u 32) 4294967295)))
    (put-u32 p v0)
    (put-u32 p v1)))

(define (ByteBuffer op g) (tuple ByteBuffer op g))
(define (ByteBuffer.op x)
  (case x (ByteBuffer (field 0 x))))
(define (ByteBuffer.g x)
  (case x (ByteBuffer (field 1 x))))
(define (ByteBuffer->bytevector x) ((ByteBuffer.g x)))

;; 接受一个inst的列表，将它们全部emit后放到一块buffer，并不关闭
(define (emit-inst-list ls)
  (let-values (((op g) (open-bytevector-output-port)))
    (for-each
     (lambda (x)
       (emit-inst op x))
     ls)
    (ByteBuffer op g)))

;; 将ByteBuffer列表转化成bytevector列表，并且在里面插入该跳转的偏移
(define (fnbuf l)
  (define (loop ls)
    (if (null? ls) 0
        (if (null? (cdr ls))
            (port-output-size (ByteBuffer.op (car ls)))
            (let ((ofst (loop (cdr ls)))
                  (p (ByteBuffer.op (car ls))))
              (put-u8 p idBRANCH)
              (put-u32 p ofst)
              (+ ofst (port-output-size p))))))
  (loop l)
  (map ByteBuffer->bytevector l))

(define (str->bv s)
  (let ([tx (make-transcoder (utf-8-codec) (eol-style none)
                             (error-handling-mode raise))])
    (string->bytevector s tx)))

(define (emit-inst p x)
  (case x
    (IConst
     (begin (put-u8 p idCONST)
            (put-u64 p (field 0 x))))
    (IBool
     (begin (put-u8 p idCONST)
            (put-u64 p (if (field 0 x) 18 34))))
    (IString
     (let ((n (string-length (field 0 x))))
       (put-u8 p idSTRING)
       (put-u32 p n)
       (put-bytevector p (str->bv (field 0 x)))
       (put-u8 p 0)))
    (ICCall
     (begin (put-u8 p idCCALL)
            (put-u32 p (field 0 x))))
    (ILoad (put-u8 p idLOAD))
    (IStop (put-u8 p idSTOP))
    (IApply (put-u8 p idAPPLY))
    (IPlus (put-u8 p idADDINT))
    (ISub (put-u8 p idSUBINT))
    (IMul (put-u8 p idMULINT))
    (IDiv (put-u8 p idDIVINT))
    (IEqual (put-u8 p idEQ))
    (IReturn (put-u8 p idRETURN))
    (IClosure
     (let-values (((op g) (open-bytevector-output-port)))
       (for-each (lambda (x) (emit-inst op x)) (field 0 x))
       (put-u8 p idCLOSURE)
       (let ((bv (g)))
         (put-u32 p (bytevector-length bv))
         (put-bytevector p bv))))
    (IGrab
     (let loop ((i 0)
                (n (field 0 x)))
       (if (< i n)
           (begin
             (put-u8 p idGRAB)
             (loop (+ i 1) n)))))
    (IPushMark (put-u8 p idPUSHMARK))
    (IAccess
     (begin (put-u8 p idACCESS)
            (put-u8 p (field 0 x))))
    (IBranch
     (let-values (((op1 g1) (open-bytevector-output-port))
                  ((op2 g2) (open-bytevector-output-port)))
       (for-each (lambda (x) (emit-inst op1 x)) (field 0 x))
       (for-each (lambda (x) (emit-inst op2 x)) (field 1 x))
       (let ((bv1 (g1))
             (bv2 (g2)))
         (put-u8 p idBRANCHIF)
         (put-u32 p (+ 5 (bytevector-length bv2)))
         (put-bytevector p bv2)
         (put-u8 p idBRANCH)
         (put-u32 p (bytevector-length bv1))
         (put-bytevector p bv1))))
    (IEqual (put-u8 p idEQ))
    (IMakeTuple
     (begin (put-u8 p idMAKEBLOCK)
            (put-u32 p (field 0 x))
            (put-u32 p (field 1 x))))
    (ILet
     (begin (put-u8 p idLET)
            (put-u8 p (field 0 x))))
    (IEndLet
     (begin (put-u8 p idENDLET)
            (put-u8 p (field 0 x))))
    (ISet
     (begin (put-u8 p idASSIGN)
            (put-u8 p (field 0 x))))
    ))
